import{C}from"./DlicuE9j.js";const B=()=>{const{$indexedDB:u}=C();return{addSongs:async n=>new Promise((e,r)=>{const o=u.transaction(["songs"],"readwrite"),l=o.objectStore("songs");l.clear(),n.forEach(t=>{l.put({id:Number(t.n),number:Number(t.n),title:String(t.title),body:t.body.map(c=>({id:c.id?Number(c.id):null,type:String(c.type),content:c.content?String(c.content):null,repeatId:c.repeatId?String(c.repeatId):null}))})}),o.oncomplete=()=>e(),o.onerror=t=>r(t.target.error)}),getSong:async n=>new Promise((e,r)=>{const t=u.transaction(["songs"],"readonly").objectStore("songs").get(Number(n));t.onsuccess=()=>e(t.result),t.onerror=c=>r(c.target.error)}),createCollection:async n=>new Promise((e,r)=>{const t=u.transaction(["collections"],"readwrite").objectStore("collections").add({name:String(n),createdAt:new Date().toISOString(),updatedAt:new Date().toISOString()});t.onsuccess=()=>e(t.result),t.onerror=c=>r(c.target.error)}),getCollections:async()=>new Promise((n,e)=>{const l=u.transaction(["collections"],"readonly").objectStore("collections").getAll();l.onsuccess=()=>n(l.result),l.onerror=t=>e(t.target.error)}),addSongToCollection:async(n,e)=>new Promise((r,o)=>{const t=u.transaction(["songCollections"],"readwrite").objectStore("songCollections"),i=t.index("collectionId_songNumber").get([n,e]);i.onsuccess=()=>{if(i.result){o(new Error("Песня уже есть в этой подборке"));return}const s=t.add({collectionId:Number(n),songNumber:Number(e),addedAt:new Date().toISOString()});s.onsuccess=()=>r(),s.onerror=a=>o(a.target.error)},i.onerror=s=>o(s.target.error)}),removeSongFromCollection:async(n,e)=>new Promise((r,o)=>{const t=u.transaction(["songCollections"],"readwrite").objectStore("songCollections"),i=t.index("collectionId_songNumber").get([Number(n),Number(e)]);i.onsuccess=()=>{if(!i.result){o(new Error("Связь не найдена"));return}const s=t.delete(i.result.id);s.onsuccess=()=>r(),s.onerror=a=>o(a.target.error)},i.onerror=s=>o(s.target.error)}),getSongsInCollection:async n=>new Promise((e,r)=>{const o=u.transaction(["songCollections","songs"],"readonly"),l=o.objectStore("songCollections"),t=o.objectStore("songs"),i=l.index("collectionId").getAll(Number(n));i.onsuccess=async()=>{const s=i.result;if(!s.length){e([]);return}const a=await Promise.all(s.map(S=>new Promise(g=>{const d=t.get(Number(S.songNumber));d.onsuccess=()=>g(d.result),d.onerror=()=>g(null)})));e(a.filter(Boolean).sort((S,g)=>S.number-g.number))},i.onerror=s=>r(s.target.error)}),getCollectionsForSong:async n=>new Promise((e,r)=>{const o=u.transaction(["songCollections","collections"],"readonly"),l=o.objectStore("songCollections"),t=o.objectStore("collections"),i=l.index("songNumber").getAll(n);i.onsuccess=async()=>{const s=i.result.map(S=>S.collectionId),a=await Promise.all(s.map(S=>new Promise(g=>{const d=t.get(S);d.onsuccess=()=>g(d.result),d.onerror=()=>g(null)})));e(a.filter(Boolean))},i.onerror=s=>r(s.target.error)}),getCollection:async n=>new Promise((e,r)=>{const t=u.transaction(["collections"],"readonly").objectStore("collections").get(Number(n));t.onsuccess=()=>e(t.result||null),t.onerror=c=>r(c.target.error)}),getAvailableCollections:async n=>new Promise((e,r)=>{const o=u.transaction(["collections","songCollections"],"readonly"),l=o.objectStore("collections"),t=o.objectStore("songCollections"),c=l.getAll(),s=t.index("songNumber").getAll(Number(n));c.onsuccess=()=>{const a=c.result;s.onsuccess=()=>{const g=s.result.map(m=>m.collectionId),d=a.filter(m=>!g.includes(m.id));e(d)}},o.onerror=a=>r(a.target.error)}),deleteCollection:async n=>new Promise((e,r)=>{const o=u.transaction(["collections","songCollections"],"readwrite"),l=o.objectStore("songCollections"),c=l.index("collectionId").openCursor(IDBKeyRange.only(n));c.onsuccess=s=>{const a=s.target.result;a&&(l.delete(a.primaryKey),a.continue())},o.objectStore("collections").delete(n),o.oncomplete=()=>e(),o.onerror=s=>r(s.target.error)}),getSongsCount:async()=>new Promise(n=>{const o=u.transaction(["songs"],"readonly").objectStore("songs").count();o.onsuccess=()=>n(o.result),o.onerror=()=>n(0)}),getSongNumbers:async()=>new Promise(n=>{const o=u.transaction(["songs"],"readonly").objectStore("songs").getAllKeys();o.onsuccess=()=>n(o.result||[]),o.onerror=()=>n([])}),getSongsCountInCollection:async n=>new Promise(e=>{const t=u.transaction(["songCollections"],"readonly").objectStore("songCollections").index("collectionId").count(Number(n));t.onsuccess=()=>e(t.result||0),t.onerror=()=>e(0)})}};export{B as u};
